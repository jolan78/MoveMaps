{\rtf1\adeflang1025\ansi\ansicpg1252\uc1\adeff0\deff0\stshfdbch0\stshfloch0\stshfhich0\stshfbi0\deflang1036\deflangfe1036{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}{\f10\fnil\fcharset2\fprq2{\*\panose 05000000000000000000}Wingdings;}
{\f37\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Lucidasans;}{\f193\froman\fcharset238\fprq2 Times New Roman CE;}{\f194\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f196\froman\fcharset161\fprq2 Times New Roman Greek;}
{\f197\froman\fcharset162\fprq2 Times New Roman Tur;}{\f198\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f199\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f200\froman\fcharset186\fprq2 Times New Roman Baltic;}
{\f201\froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\f203\fswiss\fcharset238\fprq2 Arial CE;}{\f204\fswiss\fcharset204\fprq2 Arial Cyr;}{\f206\fswiss\fcharset161\fprq2 Arial Greek;}{\f207\fswiss\fcharset162\fprq2 Arial Tur;}
{\f208\fbidi \fswiss\fcharset177\fprq2 Arial (Hebrew);}{\f209\fbidi \fswiss\fcharset178\fprq2 Arial (Arabic);}{\f210\fswiss\fcharset186\fprq2 Arial Baltic;}{\f211\fswiss\fcharset163\fprq2 Arial (Vietnamese);}
{\f213\fmodern\fcharset238\fprq1 Courier New CE;}{\f214\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f216\fmodern\fcharset161\fprq1 Courier New Greek;}{\f217\fmodern\fcharset162\fprq1 Courier New Tur;}
{\f218\fbidi \fmodern\fcharset177\fprq1 Courier New (Hebrew);}{\f219\fbidi \fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f220\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f221\fmodern\fcharset163\fprq1 Courier New (Vietnamese);}}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;
\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\nowidctlpar\wrapdefault\aspalpha\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 
\fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{\*
\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tblind0\tblindtype3\tscellwidthfts0\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv 
\ql \li0\ri0\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs20 \ltrch\fcs0 \fs20\lang1024\langfe1024\cgrid\langnp1024\langfenp1024 \snext11 \ssemihidden Normal Table;}{
\s15\ql \li0\ri0\sb240\sa120\keepn\nowidctlpar\wrapdefault\aspalpha\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af1\afs28\alang1025 \ltrch\fcs0 \f1\fs28\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 \sbasedon0 \snext16 Title;}{
\s16\ql \li0\ri0\sa120\nowidctlpar\wrapdefault\aspalpha\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 \sbasedon0 \snext16 Body Text;}{
\s17\ql \li0\ri0\sa120\nowidctlpar\wrapdefault\aspalpha\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 \sbasedon16 \snext17 List;}{
\s18\ql \li0\ri0\sb120\sa120\nowidctlpar\wrapdefault\aspalpha\faauto\rin0\lin0\itap0 \rtlch\fcs1 \ai\af0\afs24\alang1025 \ltrch\fcs0 \i\fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 \sbasedon0 \snext18 caption;}{
\s19\ql \li0\ri0\nowidctlpar\wrapdefault\aspalpha\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af37\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1031\loch\f37\hich\af0\dbch\af0\cgrid\langnp1033\langfenp1031 \sbasedon0 \snext19 Index;}{
\s20\qc \li0\ri0\sb240\sa120\keepn\nowidctlpar\wrapdefault\aspalpha\faauto\rin0\lin0\itap0 \rtlch\fcs1 \ai\af37\afs28\alang1025 \ltrch\fcs0 \i\f1\fs28\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 \sbasedon15 \snext16 Subtitle;}{
\s21\ql \li0\ri0\nowidctlpar\wrapdefault\aspalpha\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 \sbasedon0 \snext21 Index1;}{\*\cs22 \additive \f3 RTF_Num 2 1;}{\*\cs23 
\additive \f2 RTF_Num 2 2;}{\*\cs24 \additive \f10 RTF_Num 2 3;}{\*\cs25 \additive \f3 RTF_Num 2 4;}{\*\cs26 \additive \f2 RTF_Num 2 5;}{\*\cs27 \additive \f10 RTF_Num 2 6;}{\*\cs28 \additive \f3 RTF_Num 2 7;}{\*\cs29 \additive \f2 RTF_Num 2 8;}{\*\cs30 
\additive \f10 RTF_Num 2 9;}{\*\cs31 \additive \rtlch\fcs1 \af0 \ltrch\fcs0 \ul\cf2 \sbasedon10 Internet link;}{\*\cs32 \additive \ul\cf9\lang1026\langfe255\langnp1026\langfenp255 Internet link1;}}{\*\latentstyles\lsdstimax156\lsdlockeddef0}{\*\listtable
{\list\listtemplateid1{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3 \fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0
\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01o;}{\levelnumbers;}\f2 \fi-360\li1440\lin1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext
\'01\u-3929 ?;}{\levelnumbers;}\f10 \fi-360\li2160\lin2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3 \fi-360\li2880\lin2880 }{\listlevel
\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01o;}{\levelnumbers;}\f2 \fi-360\li3600\lin3600 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0
\levelindent0{\leveltext\'01\u-3929 ?;}{\levelnumbers;}\f10 \fi-360\li4320\lin4320 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3 
\fi-360\li5040\lin5040 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01o;}{\levelnumbers;}\f2 \fi-360\li5760\lin5760 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0
\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01\u-3929 ?;}{\levelnumbers;}\f10 \fi-360\li6480\lin6480 }{\listname RTF_Num 2;}\listid1}}{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}{\*\rsidtbl \rsid6451662
\rsid10056457\rsid11284514}{\*\generator Microsoft Word 11.0.0000;}{\info{\operator Lou KITE}{\creatim\yr2008\mo9\dy14\hr19\min38}{\revtim\yr2008\mo9\dy19\hr18\min33}{\version3}{\edmins36}{\nofpages5}{\nofwords2028}{\nofchars11157}{\nofcharsws13159}
{\vern24613}{\*\password 00000000}}{\*\xmlnstbl {\xmlns1 http://schemas.microsoft.com/office/word/2003/wordml}{\xmlns2 urn:schemas-microsoft-com:office:smarttags}}\paperw11906\paperh16838\margl1417\margr1417\margt1417\margb1134\gutter0\ltrsect 
\deftab708\widowctrl\ftnbj\aenddoc\hyphhotz425\donotembedsysfont0\donotembedlingdata1\grfdocevents0\validatexml0\showplaceholdtext0\ignoremixedcontent0\saveinvalidxml0\showxmlerrors0\horzdoc\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0
\dgvshow3\jcompress\viewkind1\viewscale100\rsidroot10056457 \fet0{\*\wgrffmtfilter 013f}\ilfomacatclnup0\ltrpar \sectd \ltrsect\sbknone\linex0\sectdefaultcl\sftnbj {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl2
\pnucltr\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang {\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl6
\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang 
{\pntxtb (}{\pntxta )}}\pard\plain \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\aspalpha\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 
\b\lang2057\langfe1031\langnp2057\insrsid10056457 How to use this SVN content
\par }{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 
\par First, know what you want to do:
\par {\listtext\pard\plain\ltrpar \rtlch\fcs1 \ab\af0 \ltrch\fcs0 \strike\f3\lang2057\langfe1031\langnp2057\langfenp1031\insrsid10056457\charrsid10056457 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ltrpar
\ql \fi-360\li720\ri0\nowidctlpar\wrapdefault\aspalpha\faauto\ls1\rin0\lin720\itap0 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \strike\lang2057\langfe1031\langnp2057\insrsid10056457\charrsid10056457 
Generating mmaps requires than you apply patch located on root of this SVN  to ad program and compile it so that maps are created with holes, then generate holed maps are put them in demodata\\maps, then put vmaps in demodata}{\rtlch\fcs1 \ab\af0 
\ltrch\fcs0 \strike\lang2057\langfe1031\langnp2057\insrsid10056457\charrsid11284514 \\vmaps}{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457\charrsid10056457  Now use the maps generate
d with ad.exe contained in g3d 7.0 patch
\par {\listtext\pard\plain\ltrpar \rtlch\fcs1 \af0 \ltrch\fcs0 \f3\lang2057\langfe1031\langnp2057\langfenp1031\insrsid10056457 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}{\rtlch\fcs1 \af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 
Viewing mmaps requires that you download latest mmaps from here: }{\field{\*\fldinst {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid10056457 HYPERLINK "http://trunk.dyndns.org/mmaps.rar" }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid6451662 {\*\datafield 
00d0c9ea79f9bace118c8200aa004ba90b0200000003000000e0c9ea79f9bace118c8200aa004ba90b4400000068007400740070003a002f002f007400720075006e006b002e00640079006e0064006e0073002e006f00720067002f006d006d006100700073002e00720061007200000000}}}{\fldrslt {\rtlch\fcs1 
\af0 \ltrch\fcs0 \cs32\ul\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 http://trunk.dyndns.org/mmaps.rar}}}\sectd \sbknone\linex0\sectdefaultcl\sftnbj {\rtlch\fcs1 \af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 
 and put then in mmaps folder}{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457\charrsid11284514 
\par {\listtext\pard\plain\ltrpar \rtlch\fcs1 \af0 \ltrch\fcs0 \f3\lang2057\langfe1031\langnp2057\langfenp1031\insrsid11284514 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}{\rtlch\fcs1 \af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid11284514 
You also need to copy the configuration file mmap.conf located on root path to next to the executables (bin/win32_release for windows 32 bits release compiled ones). Then configure it so that }{\rtlch\fcs1 \af0 \ltrch\fcs0 
\lang2057\langfe1031\langnp2057\insrsid11284514\charrsid11284514 mmap.datadir}{\rtlch\fcs1 \af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid11284514  point to the place containing vmaps and maps folders}{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 
\lang2057\langfe1031\langnp2057\insrsid11284514\charrsid11284514 
\par {\listtext\pard\plain\ltrpar \rtlch\fcs1 \af0 \ltrch\fcs0 \f3\lang2057\langfe1031\langnp2057\langfenp1031\insrsid11284514 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}{\rtlch\fcs1 \af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid11284514 
Configure also other options in this file}{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid11284514\charrsid11284514 
\par }\pard \ltrpar\ql \li360\ri0\nowidctlpar\wrapdefault\aspalpha\faauto\rin0\lin360\itap0\pararsid11284514 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid11284514 
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\aspalpha\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 Then build in release mode viewer and generator (if you want to use it)
\par 
\par }{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\lang2057\langfe1031\langnp2057\insrsid10056457 Viewing a mmap:
\par }{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 Open a command prompt in }{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid11284514 bin}{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 
\lang2057\langfe1031\langnp2057\insrsid10056457 \\}{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid11284514 Win32_}{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 
Release and enter map coords as arguments like:
\par }{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid11284514 Viewer}{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 .exe 0 31 28
\par 0 is map number and 31,28 coord in map style
\par This will display the content of this mmap. See xls file to know already generated ones
\par 31 is here line number and 28 column
\par 
\par }{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\lang2057\langfe1031\langnp2057\insrsid10056457 Generating mmaps:
\par }{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 To generate mmaps, they must all be next to a one already computed or have a start point. Use the cells marked with a \lquote x\rquote  in
 xls file to get one. The new start coords are created in StartCoords folder, you will see that by default I added some marked with \lquote x\rquote  in xls file.
\par For complex mmaps with city }{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \strike\lang2057\langfe1031\langnp2057\insrsid10056457\charrsid11284514 this will need a lot of memory installed (3GB at least) and /3GB option in boot
.ini file of your Windows XP/2003 to allow the process to allocate more than 2GB or RAM}{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 .
\par When you are in this configuration, you can run cmmand like this in }{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid11284514 bin}{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 \\}{\rtlch\fcs1 
\ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid11284514 Win32_}{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 Release folder:
\par }{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid11284514 Generator}{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 .exe 0 51 29 1
\par This is like viewer, and last value decides if the generator will create or not the start points for tills around. 1 to make it generate }{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid11284514 the coords}{\rtlch\fcs1 \ab\af0 
\ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457  and 0 to disable. This is for 2 pass system, you generate start points on first pass (and mmaps too) and you regenerate mmaps without redoing start points at seco
nd pass. In second pass, you should complete mmaps this time.
\par }{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\lang2057\langfe1031\langnp2057\insrsid10056457 Note:}{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457  }{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid11284514 
You can use the python file located on root folder to extract creatures coordinates from a DB}{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 .
\par }{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\lang2057\langfe1031\langnp2057\insrsid10056457 
\par Compile on Linux :
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 cd /to/the/dir/this/readme/is
\par autoreconf -ifv
\par mkdir Debug
\par cd Debug
\par ../configure
\par make
\par 
\par Now you have the Generator in Debug/Generator ( it is called mmap-generator )
\par and the viewer in Debug/Viewer ( it is called mmap-viewer )
\par 
\par To run a app cd to its directory .
\par 
\par DONT DO `make install` because the paths are hard coded and you wont have anything running
\par }{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\lang2057\langfe1031\langnp2057\insrsid10056457 
\par -------- Ralf part bellow about what functions are doing, may be outdated --------
\par 
\par 
\par 
\par This is a full package to start with. It contains some demo data, the G3D and SDL libraries and includes and all you need to just compile it.
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 
\par Here is a short description what the code does and how it is structured:
\par 
\par The whole idea is to create a map to determine where a creature or a person can walk. For that the landscape is analysed to find steep slopes and analyse the objects in the vmaps to find obstacles. 
\par 
\par The analysis needs at least one valid starting position where a person can stand and from that position the whole map is analysed. The analysis uses a kind of \'93breadth first search\'94
 to find all the valid (reachable) positions. To validate a neighbour position the height difference to the current position is checked. If the difference is too big, the position can\rquote t be reached from that source position. If the height difference
 is valid it is checked, if there is an obstacle on the path from the source to the destination position. If there is one, the destination position is reachable at least from that source position and can be used as a new source position in one of the next
 loops.
\par 
\par To gain some speed during the path finding based on the move maps, the maps are build as a 2 dimensional array (a grid). Each accessible position is marked. Naturally the grid has to have a resolution and currently that is 1. This means a 1 by 1 sq
uare in the real map is represented by one value in the move map. Therefore the move map is not as precise as the normal maps with the vmaps but should be sufficient for our purpose. If we found an obstacle smaller than a 1 by 1 square it is still represe
nted as one value in the move map. This means obstacles have priority and the imprecision of the move map may result in tiny areas marked to be invalid even if a player could walk there.
\par 
\par Unfortunately our world does not contain one distinct layer but multi
ple layers in different heights (z-Axis in our model). Naturally multiple layers can not be represented in just one flat grid map. A simple way to cover that would be to create a 3 dimensional array instead of 2 dimensions, what would consume by far too m
uch memory.
\par 
\par The idea to cover that is to create a 2 dimensional array and store the height for each position in it. An invalid height represents an unreachable position. If our map analysis finds out we reached a x,y position where the z is not unique it p
ostpones that secondly reached x,y position for the analysis. The first analysis cycle gathers all reachable x,y,z positions with a unique z and stores them in the first grid map. The next cycle uses the first position found to not have a unique z and cre
a
tes a new grid map layer starting from that position. There are as many cycles and new grid map layers until all reachable positions are covered. After the final analyses, which are very memory consuming to gain some analysis speed, a memory optimized dat
a structure is created out of the temporary analysis result.
\par 
\par Now we have a loose collection of grid layers but to find a path from one position to another we need a connection between these layers. These connection points are stored separately and build th
e linkage between the layers. To find a path from one position to another you have to know in with move map (which layer) to start and use a standard find path algorithm to find your way through the map. If you reach a position having a connection to anot
her map layer, you have to follow that link during your search.
\par 
\par Each move map layer has a x,y and z dimension due to the stored height values in the move map. You can think of it as a box. The whole analyzed area is now divided into multiple nested boxes (not so many, but some depending on the layout of the source map
)
. To start a path finding you have to know with box is the right one for a given x,y,z position. To do that in an efficient way the boxes are stored in an axis aligned BSP-Tree (AABSPTree, something a bit similar to an octree) with is used for the vmap co
llision calculation already. You use the tree to find your starting box (move map layer) for your path finding and just go through the maps.
\par 
\par So much for the theory what the analysis really does or in some points should do. Now follows a short description of the current code to give you an idea where to start when analyzing and enhancing it.
\par 
\par }{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\lang2057\langfe1031\langnp2057\insrsid10056457 As a source for the analysis you need maps containing holes. The standard ad tool does not do that. The file ad_tool_hole_patch.diff is a patch for the tool.
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 
\par For debug
ging reasons I need to visualize the data and use the G3D library for that. Unfortunately the G3D library functions dealing with vectors and the source data interpret the height differently. One is storing the height in the Z value the other is doing that
 in the Y value. Therefore the code quite often uses Z as Y and Y as Z which is really confusing sometimes. That should be cleaned up in a final version.
\par 
\par =====================================
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 
\par class}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  ModelContainerView : }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 public}{\rtlch\fcs1 \af2\afs20 
\ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  G3D::GApplet
\par This is the curr
ent starting point for the code. This class starts the map analysis and visualizes the result of that analysis. For debugging it retrieves the analysis result and all the temporary results as well. The temporary analysis results are not deleted as they sh
o
uld in a final version to be able to verify the result in graphical view. The class contains a lot of unused code and is not cleanly coded at all, but it is just used for debugging. It contains some hard codes paths to the directories containing data. The
 important methods are: 
\par 
\par ModelContainerView::init()
\par Loads the source maps, starts the analysis and displays the final results.
\par 
\par ModelContainerView::doGraphics()
\par This is the real drawing function. The debug boxes and such are drawn here.
\par 
\par 
\par }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 void}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  ModelContainerView::addMoveMapToDisplay(}{\rtlch\fcs1 
\af2\afs20 \ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 const}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  ViewCom& viewCom)
\par This is the method to bring the final calculation result to view (MoveMapContainer).
\par 
\par 
\par }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 void}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457 
 ModelContainerView::addMoveMapToDisplay(PositionControlArray<}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 unsigned}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 
\f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 char}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457 
,2>* pMovePositionArray)
\par This is the method to bring the temporary calculation result to view. This is used for debugging if the final result looks odd to see if the temporary source results are already odd.
\par 
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\aspalpha\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 =====================================
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457 
\par class MoveMapGenerator
\par That is the map analysis entry point. It initializes the work data, triggers the map analysis and after that starts the calculation of the move maps bases on the calculation.
\par 
\par }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 bool}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457 
 MoveMapGenerator::generateMoveMaps(ModelContainer** pModelContainer, ViewCom& viewCom)
\par This is the main method and still packed with debugging stuff. Currently here it is hard coded to analyse the tile 28,28 of map 0 which is the starting area of the undead. The method returns a lot of data to the ModelContainerView. A final vers
ion would not do that.
\par 
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\aspalpha\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 =====================================
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457 
\par }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 class}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  AreaTreeMap :  }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 
\f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 public}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  IVMapManager
\par To analyse the hight we need to check the vmaps. To speed up the hight lookup the analysed map is split up into small tubes arranged in a map. Checking the hight in a small tube is much faster than allways taking the full map for that.
\par 
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\aspalpha\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 =====================================
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 
\par class}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  VectorMoveMap
\par Here we have the analysis of the maps and the creation of the temporary results consuming heaps to memory. For that analysis we need some helper classes. The class contains some unused and debugging code.
\par I did some performance enhancements and one was to check 2 directions at a time. It is some time ago I typed that code and I do not remember right away why it was faster, but I was able to seed it up a bit by that.
\par 
\par }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 bool}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457 
 VectorMoveMap::processMapGrid(CalcHelper& pCalcHelper, ModelContainer* pMc)
\par This is the entry point. The result of the analysis is stored in a array of MoveLayer* classes, kept in }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 class}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 
\f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  CalcHelper.
\par 
\par }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 void}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  VectorMoveMap::findStartVector(}{\rtlch\fcs1 \af2\afs20 
\ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 const}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  Vector3& pLow, }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 
\f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 const}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  Vector3& pHigh, Array<Vector3>& pStartArray)
\par Here we get the valid start positions for our search. In the final version the positions reached at the edges of one map tile have to be the starti
ng positions for the analyses of the neighbour map tile. Currently we just read the starting positions of the different races. This means we currently are only able to analyse the starting areas map time of the different races, due to the lack of valid st
art positions.
\par 
\par }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 float}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  VectorMoveMap::getHeight(}{\rtlch\fcs1 \af2\afs20 
\ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 const}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  Vector3& pPos, CalcHelper& pCalcHelper)
\par Here the height of a position is calculated. It is assumed that the maps are containing holes and a hole is represented as a value -1000. To speed up the height loo
kup we store each calculated height as a fixed point long value in a 3D grid map. The height of one x,y with a basis z position is used multiple times in the analysis, so storing the height uses a loot of memory, but is much faster than analysing the vmap
s each time again.
\par 
\par 
\par 
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\aspalpha\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 =====================================
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 
\par class}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  MoveLayer
\par This is the temporary storage of the analysis result for one move map \'93box\'94.
\par 
\par 
\par }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 bool}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  MoveLayer::processOneStep(}{\rtlch\fcs1 \af2\afs20 
\ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 const}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  Vector3& pPos, }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 
\f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 int}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  pHeightDiff, }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 
\f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 int}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  pVal)
\par This method is called from VectorMoveMap during the analyses and stores a value in the map. This is the central method here.
\par 
\par 
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\aspalpha\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 =====================================
\par }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 
\par class}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  MoveMapContainer
\par This is the final data structure being used for the path finding. It contains all the resulting analysis data. The constructor is the main conversion method to transform the temporary MoveLayer to the final data structure.
\par 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 =====================================
\par }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457 MoveMapBox : }{\rtlch\fcs1 \af0 \ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 public}{\rtlch\fcs1 \af0 \ltrch\fcs0 
\f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  BitArray<}{\rtlch\fcs1 \af0 \ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 unsigned}{\rtlch\fcs1 \af0 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  }{
\rtlch\fcs1 \af0 \ltrch\fcs0 \f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 char}{\rtlch\fcs1 \af0 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457 , 8>}{\rtlch\fcs1 \af0 \ltrch\fcs0 
\lang2057\langfe1031\langnp2057\insrsid10056457 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457 This is the f
inal data structure of one move map (one layer). It stores the height of each reachable position relative to a base vector. The height is stored as a fixed point 8 bit value to save memory. Therefore the MoveMapBox has a maximum height span it can represe
nt. If we find position outside that span, we have to create a new map layer. The analysis methods (MoveLayer::processOneStep) take care of that. The current max span is  }{\rtlch\fcs1 \af0 \ltrch\fcs0 
\f2\fs20\cf2\lang2057\langfe1031\langnp2057\insrsid10056457 #define}{\rtlch\fcs1 \af0 \ltrch\fcs0 \f2\fs20\lang2057\langfe1031\langnp2057\insrsid10056457  MAX_BOX_HIGHT {\*\xmlopen\xmlns2{\factoidname metricconverter}{\xmlattr\xmlattrns0{\xmlattrname 
ProductID}{\xmlattrvalue 62 in}}}62 in{\*\xmlclose} MoveLayer.h. This value has to correspond with the MoveMapBox::getCharHeight() and MoveMapBox::getFloatHeight() methods.}{\rtlch\fcs1 \af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457 

\par 
\par =====================================
\par 
\par I hope that is enough to start with. There are some helper classes involved as well, but I think you will figure out what they are supposed to do. If not, just ask.
\par 
\par Ralf
\par  
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \lang2057\langfe1036\langnp2057\langfenp1036\insrsid10056457\charrsid10056457 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \lang2057\langfe1036\langnp2057\langfenp1036\insrsid10056457 PS: As you clearly see English is not my mother tongue, so please correct my text... :)}{\rtlch\fcs1 \af0 \ltrch\fcs0 
\lang2057\langfe1036\langnp2057\langfenp1036\insrsid10056457\charrsid10056457 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \lang2057\langfe1031\langnp2057\insrsid10056457  
\par }}